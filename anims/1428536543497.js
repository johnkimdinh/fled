{"name":"Pulsing Lights","filename":"1428536543497.js","author":"Ben","code":"// example code, renders a basic rainbow\r\nvar tweenedValues = {\r\n\thue: 0,\r\n\toffset: 0\r\n};\r\n\r\n// this animation creates 3 virtual lights that bounce around the space\r\n\r\nvar lights = [];\r\n\r\nfunction createLight(c, radius, x, y) {\r\n    lights.push({\r\n        radius: radius,\r\n        color: c,\r\n        attenuation:1,\r\n        x: x,\r\n        y: y,\r\n        epsilon: 0.00001\r\n    });\r\n}\r\nfunction distance(x,y, a,b) {\r\n    return Math.sqrt(\r\n        ((a-x)*(a-x)) +\r\n        ((b-y)*(b-y))\r\n    );\r\n};\r\n\r\nfunction renderLights(display, lights) {\r\n    // iterate over all pixels\r\n    // calculate how much effect each light should have on the pixel\r\n    // apply colors in sequence to get light effect\r\n    for (var i=0; i < display.leds.length; i++) {\r\n\t\tvar x = i%display.cols,\r\n\t\t\ty = Math.floor(i/display.cols);\r\n\t\tfor (var k=0; k < lights.length; k++) {\r\n\t\t    var light = lights[k];\r\n\t\t    \r\n\t\t    var dist = distance(light.x, light.y, x, y);\r\n\t\t    // use inverse square law for distance\r\n\t\t    var deltaDist = (dist-light.radius)*light.attenuation;\r\n\t\t    var deltaDist2 = deltaDist*deltaDist;\r\n\t\t    \r\n\t\t    var attenuation = 1;\r\n\t\t    if (deltaDist2 > light.epsilon) {\r\n\t\t        attenuation = 1/deltaDist2;\r\n\t\t        if (attenuation > 1) {\r\n\t\t            attenuation = 1;\r\n\t\t        }\r\n\t\t    }\r\n\t\t    if (attenuation > 1) {\r\n\t\t        attenuation = 1;\r\n\t\t    }\r\n\t\t    if (dist < light.radius) {\r\n\t\t        attenuation = 1;\r\n\t\t    }\r\n\t\t    \r\n\t\t    var c = light.color.clone();\r\n\t        c.multiplyScalar(attenuation);\r\n\t\t    display.setColor(i, c, 'add');\r\n\t\t}\r\n    }\r\n}\r\nfunction random(min,max) {\r\n    return Math.floor(Math.random()*(max-min)) + min;\r\n}\r\nreturn {\r\n\tinit: function(display,timeline) {\r\n\t\tthis.display = display;\r\n\r\n      \tdisplay.tween(tweenedValues,{\r\n          to: {hue: 1},\r\n          duration: 5000,\r\n          repeat: Infinity,\r\n          yoyo: true,\r\n          delay: 0,\r\n          easing: TWEEN.Easing.Cubic.InOut\r\n        });\r\n        \r\n        createLight(new Color(0xFF0000), Math.random()*0.5, random(0,display.cols),random(0,display.rows));\r\n        createLight(new Color(0x00FF00), Math.random()*0.5, random(0,display.cols),random(0,display.rows));\r\n        createLight(new Color(0x0000FF), Math.random()*0.5, random(0,display.cols),random(0,display.rows));\r\n        \r\n        display.tween(lights[0],{\r\n          to: {radius: Math.random()*2},\r\n          duration: 2000,\r\n          repeat: Infinity,\r\n          yoyo: true,\r\n          delay: Math.random()*1000\r\n        });\r\n        display.tween(lights[1],{\r\n          to: {radius: Math.random()*2},\r\n          duration: 2000,\r\n          repeat: Infinity,\r\n          yoyo: true,\r\n          delay: Math.random()*1000\r\n        });\r\n        display.tween(lights[2],{\r\n          to: {radius: Math.random()*2},\r\n          duration: 2000,\r\n          repeat: Infinity,\r\n          yoyo: true,\r\n          delay: Math.random()*1000\r\n        });\r\n        \r\n        display.tween(tweenedValues,{\r\n          to: {offset: 1},\r\n          duration: 2000,\r\n          repeat: Infinity\r\n        });\r\n        \r\n        lights[0].xOff = Math.random();\r\n        lights[0].yOff = Math.random();\r\n        lights[1].xOff = Math.random();\r\n        lights[1].yOff = Math.random();\r\n        lights[2].xOff = Math.random();\r\n        lights[2].yOff = Math.random();\r\n\t},\r\n\tonUpdate: function(display, data) {\r\n\t    display.clear();\r\n\t\trenderLights(display, lights);\r\n\t}\r\n};","publish":true,"script":{}}