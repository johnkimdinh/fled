<html>
<head>
	<script src="/socket.io/socket.io.js"></script>
	<script src="/jquery-1.10.0.min.js"></script>
	<script src="/Detector.js"></script>
	<script src="/stats.min.js"></script>
	<script src="/dat.gui.min.js"></script>
	<script src="/paper-full.min.js"></script>
	<style type="text/css">
		#container {
			position: absolute;
			top: 0px;
			left: 0px;
			width: 30%;
			background: black;
		}
		#animationName {
			position: absolute;
			bottom: 0;
			right: 0;
			left: 0;
			background: rgba(0,0,0,0.5);
			color: white;
			font-weight: bold;
			text-transform: uppercase;
			font-size: 18px;
			padding: 8px;
			text-align: right;
		}
		#canvas {
			width: 100%;
			height: 100%;
			background: black;
		}
	</style>
</head>
<body>
	<div id="container">
		<canvas id="canvas"></canvas>
	</div>
	<div id="animationName"></div>

	<script>
		var socket = io.connect('http://localhost');
		var presets = {
		};
		// some constants for use by the diodome, these are mesh specific so if we change the mesh we have to go recalculate these
		var DisplayConstants = {
			MAX_LEDS: 96
		};

		(function() {
		  var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
									  window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
		  window.requestAnimationFrame = requestAnimationFrame;
		})();

		var Display = function() {
			this.init();
		};

		Display.prototype = {
			container: null,

			windowWidth:0,
			windowHeight:0,

			display: null,
			// the animation being shown/edited right now
			theAnim: null,
			// the actual animation instance
			currentAnim: null,

			// the codemirror editor
			codeEditor: null,

			init: function() {

				this.leds = [];
				// initialize
				for (var i=0; i < DisplayConstants.MAX_LEDS; i++) {
					this.leds.push({red: 1, green: 0, blue: 0});
				}

				this.initScene();
				this.addListeners();
				// create the dome object to represent our dome and its leds

				this.onWindowResize();
				this.onUpdate();


				var that = this;
				socket.on('reconnect', function() {
					that.updateServerSettings();
				});
				socket.on('update', function (data) {
					// loop over data and update led info
					for (var i=0; i < that.leds.length; i++) {
						var index = i*3,
							led = that.leds[i];
						led.red = data[index]/254;
						led.green = data[index+1]/254;
						led.blue = data[index+2]/254;
					}
				});

				// initialize settings to nothing
				this.settings = {};
				// events for setting and updating gui state
				socket.on('settings', function(data) {
					that.initGUI(data);
				});
				socket.on('animation-change', function(animName) {
					that.onAnimationChange(animName);
				})
			},
			onAnimationChange: function(animName) {
				$('#animationName').text(animName);
			},
			updateGUI: function() {
				var gui = this.gui;
				// Iterate over all controllers
				for (var i in gui.__controllers) {
					gui.__controllers[i].updateDisplay();
				}
			},
			nextAnim: function() {
				socket.emit('nextAnim');
			},
			updateServerSettings: function() {

				// Iterate over all controllers
				var gui = this.gui;
				for (var i in gui.__controllers) {
					var val = gui.__controllers[i].getValue();
					if (gui.__controllers[i].__onChange) {
						gui.__controllers[i].__onChange(val);	
					}
				}
				for (var i in gui.__folders) {
					var folder = gui.__folders[i];

					for (var i in folder.__controllers) {
						var val = folder.__controllers[i].getValue();
						if (folder.__controllers[i].__onChange) {
							folder.__controllers[i].__onChange(val);	
						}
					}
				}
			},
			initGUI: function(settings) {
				// store it for later reference
				$.extend(true, this.settings, settings);

				if (this.gui) {
					// don't create the gui twice...just do an update
					this.updateGUI();
					return;
				}

				// setup gui
				var gui = new dat.GUI({load:presets}),
					c = null,
					that = this;
				this.gui = gui;

				// loop over anims and create gui for them
				var animsList = gui.addFolder('Animations');

				gui.remember(settings.animations);

				for(var animName in settings.animations) {
					c = animsList.add(settings.animations, animName);
					c.onChange(function(value) {
						if (value) {
							socket.emit('animation-activate', this.property);
						} else {
							socket.emit('animation-deactivate', this.property);
						}
					});
				}

				gui.remember(settings.animation);
				gui.remember(settings.transition);

				var animSettings = gui.addFolder('Animation Settings');
				c = animSettings.add(settings.animation, 'durationMin', 3, 120);
				c.onChange(function(value) {
					socket.emit('settings', { animation: { durationMin: value } });
				});
				c = animSettings.add(settings.animation, 'durationMax', 3, 300);
				c.onChange(function(value) {
					socket.emit('settings', { animation: { durationMax: value } });
					return value;
				});


				var transitionSettings = gui.addFolder('Transition Settings');
				c = transitionSettings.add(settings.transition, 'durationMin', 0.5, 10);
				c.onChange(function(value) {
					socket.emit('settings', { transition: { durationMin: value } });
					return value;
				});
				c = transitionSettings.add(settings.transition, 'durationMax', 0.5, 30);
				c.onChange(function(value) {
					socket.emit('settings', { transition: { durationMax: value } });
					return value;
				});

				var colorBalance = gui.addFolder('Color Balance');
				c = colorBalance.add(settings.colorBalance, 'red', 0, 1.0);
				c.onChange(function(value) {
					socket.emit('settings', { colorBalance: { red: value } });
					return value;
				});
				c = colorBalance.add(settings.colorBalance, 'green', 0, 1.0);
				c.onChange(function(value) {
					socket.emit('settings', { colorBalance: { green: value } });
					return value;
				});
				c = colorBalance.add(settings.colorBalance, 'blue', 0, 1.0);
				c.onChange(function(value) {
					socket.emit('settings', { colorBalance: { blue: value } });
					return value;
				});

				c = gui.add(settings, 'speedFactor', 0.01, 3);
				c.onChange(function(value) {
					socket.emit('settings', { speedFactor: value });
					return value;
				});

				gui.add(this, 'nextAnim');
				// trigger updates on all values
				this.updateServerSettings();

				// hook up listener to fire reset index event after preset change
				$('.dg .save-row select').on('change', function(ev) {
					socket.emit('reset-index');
				});
			},
			initScene: function() {

				this.container = $( '#container' );
				this.canvas = $('#canvas');

				paper.setup(this.canvas[0]);

				this.createLEDS();
				// SETUP Canvas
			},
			createLEDS: function() {
				// calculate width/height of canvas
				var width = paper.view.size.width;
				var height = paper.view.size.height;

				// calculate offset to indent LEDs
				var offsetX = Math.round((width / 12)/2);
				var offsetY = Math.round((height / 8)/2);
				var gapX = Math.round(width/12);
				var gapY = Math.round(height/8);
				var radius = (Math.round(width / 12)/2)*1.5;

				if (this.ledObjects) {
					for (var i=0; i < this.ledObjects.length; i++) {
						this.ledObjects[i].remove();
					}
				}

				this.ledObjects = [];
				for (var i=0; i < this.leds.length; i++) {
					var x = i%12;
					var y = Math.floor(i/12);
					var posX = offsetX + (gapX*x);
					var posY = offsetY + (gapY*y);

					var led = new paper.Path.Circle({
						center: [posX,posY],
						radius: radius
					});
					led.fillColor = {
						gradient: {
							stops: [
								{red: 0, green: 0, blue: 0},
								{red: 0, green: 0, blue: 0}
							],
							radial: true
						},
						origin: led.position,
						destination: led.bounds.rightCenter
					};

					this.ledObjects.push(led);
				}
			},
			addListeners: function() {
				var container = this.container;

				$(window).on('resize', $.proxy(this.onWindowResize, this));
			},
			
			onUpdate: function() {
				this.render();
				requestAnimationFrame($.proxy(this.onUpdate,this));
			},

			onWindowResize: function() {

				if ( this.windowWidth != window.innerWidth || this.windowHeight != window.innerHeight ) {

					this.windowWidth  = window.innerWidth;
					this.windowHeight = window.innerHeight;

					// RESIZE CANVAS
					var width = this.container.width();
					var height = Math.round(width/1.5);
					this.canvas.height(height);
					this.canvas.attr('height', height);

					paper.view.size.width = width;
					paper.view.size.height = height;

					this.createLEDS();
				}
			},

			render: function() {
				if (!this.leds) {
					return;
				}
				for (var i=0; i < this.leds.length; i++) {
					var circle = this.ledObjects[i];
					circle.fillColor.gradient.stops[0].color = this.leds[i];
				}
				
				paper.view.draw();
				
			}
		};

		window.onload = function() {
		  var editor = new Display();
		};
	</script>
</body>
</html>